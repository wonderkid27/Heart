<!doctype html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Heart Particle</title>
    <style>
      :root {
        color-scheme: dark;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
        overflow: hidden;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      #c {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      .hint {
        position: fixed;
        left: 14px;
        bottom: 12px;
        color: rgba(210, 245, 255, 0.65);
        font-size: 12px;
        letter-spacing: 0.2px;
        user-select: none;
        pointer-events: none;
        text-shadow: 0 0 14px rgba(130, 240, 255, 0.35);
      }
      .hint kbd {
        padding: 2px 6px;
        border-radius: 6px;
        border: 1px solid rgba(160, 240, 255, 0.25);
        background: rgba(0, 40, 50, 0.35);
        box-shadow: 0 0 18px rgba(130, 240, 255, 0.12);
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div class="hint">Nhấn <kbd>Space</kbd> để tạm dừng/tiếp tục</div>
    <script>
      (() => {
        "use strict";

        const TAU = Math.PI * 2;
        const clamp01 = (v) => Math.max(0, Math.min(1, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const smoothstep = (a, b, t) => {
          const x = clamp01((t - a) / (b - a));
          return x * x * (3 - 2 * x);
        };

        const prefersReducedMotion =
          window.matchMedia &&
          window.matchMedia("(prefers-reduced-motion: reduce)").matches;

        const canvas = document.getElementById("c");
        const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });

        const bgCanvas = document.createElement("canvas");
        const bgCtx = bgCanvas.getContext("2d", { alpha: false, desynchronized: true });

        const bloomCanvas = document.createElement("canvas");
        const bloomCtx = bloomCanvas.getContext("2d", { alpha: true, desynchronized: true });

        const state = {
          w: 0,
          h: 0,
          dpr: 1,
          heartCx: 0,
          heartCy: 0,
          baseCx: 0,
          baseCy: 0,
          scale: 1,
        };
        let requestedReset = true;

        function mulberry32(seed) {
          let a = seed >>> 0;
          return () => {
            a |= 0;
            a = (a + 0x6d2b79f5) | 0;
            let t = Math.imul(a ^ (a >>> 15), 1 | a);
            t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
          };
        }

        const SEED = (Date.now() ^ ((Math.random() * 1e9) | 0)) >>> 0;
        const rng = mulberry32(SEED);

        const BLOOM = {
          down: prefersReducedMotion ? 0.72 : 0.55,
          intensity: prefersReducedMotion ? 0.55 : 0.95,
        };

        function makeGlowSprite(size, inner, mid, outer) {
          const c = document.createElement("canvas");
          c.width = c.height = size;
          const g = c.getContext("2d");
          const r = size / 2;
          const grad = g.createRadialGradient(r, r, 0, r, r, r);
          grad.addColorStop(0, inner);
          grad.addColorStop(0.35, mid);
          grad.addColorStop(1, outer);
          g.fillStyle = grad;
          g.beginPath();
          g.arc(r, r, r, 0, TAU);
          g.fill();
          return c;
        }

        const spriteDot = makeGlowSprite(
          64,
          "rgba(220, 255, 255, 1)",
          "rgba(140, 240, 255, 0.6)",
          "rgba(0, 160, 220, 0)"
        );
        const spriteHot = makeGlowSprite(
          96,
          "rgba(240, 255, 255, 1)",
          "rgba(120, 235, 255, 0.7)",
          "rgba(0, 140, 210, 0)"
        );

        function heartBoundary(t) {
          const s = Math.sin(t);
          const c = Math.cos(t);
          const x = 16 * s * s * s;
          const y = 13 * c - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
          return { x, y: -y };
        }

        function makeHeartPoints(count) {
          const points = new Array(count);
          for (let i = 0; i < count; i++) {
            const t = rng() * TAU;
            const b = heartBoundary(t);
            const isEdge = rng() < 0.22;
            const u = isEdge ? 0.86 + rng() * 0.14 : Math.sqrt(rng());
            let x = b.x * u;
            let y = b.y * u;
            x += (rng() - 0.5) * 0.75;
            y += (rng() - 0.5) * 0.75;
            points[i] = { x, y };
          }
          return points;
        }

        const PARTICLE_COUNT = prefersReducedMotion ? 900 : 3600;
        const HEART_POINTS = makeHeartPoints(PARTICLE_COUNT);

        const PHASE = {
          cycleMs: prefersReducedMotion ? 14000 : 21000,
          buildMs: prefersReducedMotion ? 3500 : 6500,
          holdMs: prefersReducedMotion ? 6500 : 9500,
          disperseMs: prefersReducedMotion ? 4000 : 5000,
        };

        function rebuildBackground() {
          const { w, h } = state;
          bgCanvas.width = w;
          bgCanvas.height = h;
          bgCtx.setTransform(1, 0, 0, 1, 0, 0);

          bgCtx.fillStyle = "#000";
          bgCtx.fillRect(0, 0, w, h);

          const cx = w * 0.5;
          const cy = h * 0.42;
          const r = Math.max(w, h) * 0.78;
          const g = bgCtx.createRadialGradient(cx, cy, 0, cx, cy, r);
          g.addColorStop(0, "rgba(0, 52, 72, 0.55)");
          g.addColorStop(0.35, "rgba(0, 24, 36, 0.22)");
          g.addColorStop(1, "rgba(0, 0, 0, 1)");
          bgCtx.fillStyle = g;
          bgCtx.fillRect(0, 0, w, h);

          const starRng = mulberry32((SEED ^ 0xdecafbad) >>> 0);
          const starCount = prefersReducedMotion ? 140 : Math.floor(220 + Math.min(w, h) * 0.1);
          bgCtx.save();
          bgCtx.globalCompositeOperation = "screen";
          for (let i = 0; i < starCount; i++) {
            const x = starRng() * w;
            const y = starRng() * h;
            const rr = 0.35 + Math.pow(starRng(), 2.7) * 1.9;
            const a = 0.04 + Math.pow(starRng(), 1.85) * 0.36;
            bgCtx.fillStyle = `rgba(180, 245, 255, ${a})`;
            bgCtx.beginPath();
            bgCtx.arc(x, y, rr, 0, TAU);
            bgCtx.fill();
          }
          bgCtx.restore();

          const vig = bgCtx.createRadialGradient(
            w * 0.5,
            h * 0.5,
            Math.min(w, h) * 0.2,
            w * 0.5,
            h * 0.5,
            Math.max(w, h) * 0.92
          );
          vig.addColorStop(0, "rgba(0,0,0,0)");
          vig.addColorStop(1, "rgba(0,0,0,0.88)");
          bgCtx.fillStyle = vig;
          bgCtx.fillRect(0, 0, w, h);
        }

        function computeLayout() {
          const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
          const w = Math.max(1, Math.floor(window.innerWidth));
          const h = Math.max(1, Math.floor(window.innerHeight));
          canvas.width = Math.floor(w * dpr);
          canvas.height = Math.floor(h * dpr);
          canvas.style.width = w + "px";
          canvas.style.height = h + "px";
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          state.w = w;
          state.h = h;
          state.dpr = dpr;
          state.scale = Math.min(w, h) / 58;
          state.heartCx = w * 0.5;
          state.heartCy = h * 0.38;
          state.baseCx = state.heartCx;
          state.baseCy = h * 0.74;

          bloomCanvas.width = Math.max(1, Math.floor(w * BLOOM.down));
          bloomCanvas.height = Math.max(1, Math.floor(h * BLOOM.down));
          bloomCtx.setTransform(BLOOM.down, 0, 0, BLOOM.down, 0, 0);
          bloomCtx.clearRect(0, 0, w, h);

          rebuildBackground();

          ctx.globalAlpha = 1;
          ctx.globalCompositeOperation = "source-over";
          ctx.drawImage(bgCanvas, 0, 0, w, h);
          requestedReset = true;
        }

        window.addEventListener("resize", computeLayout, { passive: true });
        computeLayout();

        function placeOnBase(p, tMs) {
          const { baseCx, baseCy, scale } = state;
          const ring = scale * 10.5;
          const a = p.baseAngle + tMs * (0.0019 + p.spin * 0.001);
          const r = ring * (0.25 + 0.85 * p.baseRadius);
          p.x = baseCx + Math.cos(a) * r * 2.1;
          p.y = baseCy + Math.sin(a) * r * 0.58;
          p.px = p.x;
          p.py = p.y;
          p.vx = 0;
          p.vy = 0;
        }

        function particleColorAlpha(p, tMs, phase) {
          const tw = 0.7 + 0.3 * Math.sin(tMs * 0.006 + p.twinkle);
          const base = p.brightness * tw;
          if (phase.name === "build") return base * smoothstep(0, 1, phase.k) * p.reveal;
          if (phase.name === "hold") return base;
          return base * (1 - phase.k);
        }

        function phaseAt(tMs) {
          const t = tMs % PHASE.cycleMs;
          const b = PHASE.buildMs;
          const h = PHASE.holdMs;
          const d = PHASE.disperseMs;
          if (t < b) return { name: "build", k: t / b, t };
          if (t < b + h) return { name: "hold", k: (t - b) / h, t };
          return { name: "disperse", k: (t - b - h) / d, t };
        }

        function makeParticle(i) {
          return {
            i,
            x: 0,
            y: 0,
            px: 0,
            py: 0,
            vx: 0,
            vy: 0,
            size: 0.75 + rng() * 1.7,
            brightness: 0.65 + rng() * 0.55,
            twinkle: rng() * TAU,
            baseAngle: rng() * TAU,
            baseRadius: rng(),
            spin: rng(),
            delay: rng(),
            reveal: 0,
            scatter: rng(),
            wander: rng() * TAU,
          };
        }

        const particles = new Array(PARTICLE_COUNT);
        for (let i = 0; i < particles.length; i++) particles[i] = makeParticle(i);

        function resetCycle(tMs) {
          for (const p of particles) {
            p.delay = Math.pow(rng(), 1.25) * 0.74;
            p.reveal = 0;
            p.scatter = rng();
            p.baseAngle = rng() * TAU;
            p.baseRadius = rng();
            p.wander = rng() * TAU;
            p.vx = 0;
            p.vy = 0;
            placeOnBase(p, tMs);
          }
        }

        resetCycle(0);

        function drawBase(g, tMs, phase, mode = "main") {
          const { baseCx, baseCy, scale } = state;
          const pulse = 1 + 0.06 * Math.sin(tMs * 0.0022);
          const r = scale * (mode === "bloom" ? 13.6 : 12.5) * pulse;

          const intensity = phase.name === "disperse" ? 1 - phase.k * 0.65 : 1;
          const gain = mode === "bloom" ? 1.25 : 1;

          g.save();
          g.globalCompositeOperation = "lighter";

          g.save();
          g.translate(baseCx, baseCy);
          g.scale(2.35, 0.75);
          const grad = g.createRadialGradient(0, 0, 0, 0, 0, r);
          grad.addColorStop(0, `rgba(200, 255, 255, ${0.92 * intensity * gain})`);
          grad.addColorStop(0.24, `rgba(120, 242, 255, ${0.48 * intensity * gain})`);
          grad.addColorStop(0.78, `rgba(40, 200, 255, ${0.16 * intensity * gain})`);
          grad.addColorStop(1, "rgba(0, 0, 0, 0)");
          g.fillStyle = grad;
          g.beginPath();
          g.arc(0, 0, r, 0, TAU);
          g.fill();
          g.restore();

          const ringCount = prefersReducedMotion ? 9 : mode === "bloom" ? 12 : 26;
          const ringAlpha = (mode === "bloom" ? 0.09 : 0.07) * (1 - phase.k * 0.35);
          g.lineCap = "round";
          for (let i = 0; i < ringCount; i++) {
            const a0 = tMs * 0.00125 + (i / ringCount) * TAU;
            const a1 = a0 + (0.35 + 0.45 * Math.sin(tMs * 0.0015 + i)) * 0.92;
            const rr = r * (1.12 + 0.24 * Math.sin(i * 9.2 + tMs * 0.001));
            g.strokeStyle = `rgba(160, 245, 255, ${ringAlpha})`;
            g.lineWidth = mode === "bloom" ? 2.1 : 1.15;
            g.beginPath();
            g.ellipse(baseCx, baseCy, rr * 2.1, rr * 0.62, 0, a0, a1);
            g.stroke();
          }

          g.restore();
        }

        function drawThreads(g, tMs, phase, mode = "main") {
          if (prefersReducedMotion) return;
          const { baseCx, baseCy, heartCx, heartCy, scale } = state;

          const intensity =
            phase.name === "build"
              ? smoothstep(0.08, 1, phase.k)
              : phase.name === "hold"
              ? 0.55
              : (1 - phase.k) * 0.42;
          if (intensity <= 0.001) return;

          const count = mode === "bloom" ? 10 : 16;
          const rx = scale * 22;
          const ry = scale * 6.7;

          g.save();
          g.globalCompositeOperation = "lighter";
          g.lineCap = "round";
          g.lineJoin = "round";
          for (let i = 0; i < count; i++) {
            const a = tMs * 0.00125 + i * 1.72;
            const sx = baseCx + Math.cos(a) * rx;
            const sy = baseCy + Math.sin(a) * ry;
            const ex = heartCx + Math.sin(a * 0.72) * scale * 6.5;
            const ey = heartCy + Math.cos(a * 0.94) * scale * 4.2;
            const wob = Math.sin(a * 2.35 + tMs * 0.002) * scale * 10.5;
            const lift = scale * (18 + 10 * Math.sin(a + tMs * 0.003));
            const cxp = (sx + ex) * 0.5 + wob;
            const cyp = (sy + ey) * 0.5 - lift;
            const flick = 0.45 + 0.55 * Math.sin(i * 12.3 + tMs * 0.003);
            const aLine = (mode === "bloom" ? 0.07 : 0.045) * intensity * (0.55 + 0.45 * flick);
            g.strokeStyle = `rgba(180, 250, 255, ${aLine})`;
            g.lineWidth = mode === "bloom" ? 2.4 : 1.1;
            g.beginPath();
            g.moveTo(sx, sy);
            g.quadraticCurveTo(cxp, cyp, ex, ey);
            g.stroke();
          }
          g.restore();
        }

        function backgroundFade(phase) {
          ctx.globalCompositeOperation = "source-over";
          let a =
            phase.name === "build"
              ? lerp(0.24, 0.13, phase.k)
              : phase.name === "hold"
              ? 0.11
              : lerp(0.11, 0.22, phase.k);
          if (phase.name === "disperse") a += smoothstep(0.72, 1, phase.k) * 0.26;
          ctx.globalAlpha = a;
          ctx.drawImage(bgCanvas, 0, 0, state.w, state.h);
          ctx.globalAlpha = 1;
        }

        let lastT = 0;
        let paused = false;
        let pauseAt = 0;
        let startAt = performance.now();

        window.addEventListener("keydown", (e) => {
          if (e.code !== "Space") return;
          e.preventDefault();
          paused = !paused;
          if (paused) pauseAt = performance.now();
          else startAt += performance.now() - pauseAt;
        });

        function step(now) {
          if (paused) {
            requestAnimationFrame(step);
            return;
          }

          const tMs = now - startAt;
          const ph = phaseAt(tMs);
          if (requestedReset) {
            resetCycle(tMs);
            requestedReset = false;
            lastT = ph.t;
          } else if (ph.t < lastT) {
            resetCycle(tMs);
          }
          lastT = ph.t;

          backgroundFade(ph);
          bloomCtx.globalCompositeOperation = "source-over";
          const bloomFade = ph.name === "hold" ? 0.18 : ph.name === "build" ? 0.14 : 0.28;
          bloomCtx.fillStyle = `rgba(0,0,0,${bloomFade})`;
          bloomCtx.fillRect(0, 0, state.w, state.h);

          drawBase(ctx, tMs, ph, "main");
          drawThreads(ctx, tMs, ph, "main");
          drawBase(bloomCtx, tMs, ph, "bloom");
          drawThreads(bloomCtx, tMs, ph, "bloom");

          const { heartCx, heartCy, baseCx, baseCy, scale } = state;
          const pulse = 1 + 0.03 * Math.sin(tMs * 0.0027);
          const heartScale = scale * pulse;
          const rot = tMs * 0.000085 + 0.08 * Math.sin(tMs * 0.0007);
          const cr = Math.cos(rot);
          const sr = Math.sin(rot);

          const pull =
            ph.name === "build" ? 0.018 : ph.name === "hold" ? 0.012 : lerp(0.01, 0.002, ph.k);
          const drag = ph.name === "disperse" ? lerp(0.88, 0.96, ph.k) : 0.86;

          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          bloomCtx.save();
          bloomCtx.globalCompositeOperation = "lighter";

          for (const p of particles) {
            p.px = p.x;
            p.py = p.y;

            const pt = HEART_POINTS[p.i];
            const hx = pt.x * cr - pt.y * sr;
            const hy = pt.x * sr + pt.y * cr;
            const targetHeartX = heartCx + hx * heartScale;
            const targetHeartY = heartCy + hy * heartScale;

            let tx = targetHeartX;
            let ty = targetHeartY;

            if (ph.name === "build") {
              const emit = smoothstep(0, 1, (ph.k - p.delay) / 0.35);
              p.reveal = emit;

              if (emit < 0.02) {
                const ring = scale * 10.5;
                const a = p.baseAngle + tMs * (0.0019 + p.spin * 0.001);
                const r = ring * (0.25 + 0.85 * p.baseRadius);
                tx = baseCx + Math.cos(a) * r * 2.1;
                ty = baseCy + Math.sin(a) * r * 0.58;
              } else {
                const jet = 1 - smoothstep(0, 1, (ph.k - p.delay) / 0.22);
                p.vy -= jet * (0.75 + p.baseRadius * 0.8);
                p.vx += Math.sin(p.wander + tMs * 0.004) * jet * 0.35;
              }
            } else if (ph.name === "disperse") {
              const k = ph.k;
              const spread = 1 + 1.7 * k * k;
              tx = heartCx + (targetHeartX - heartCx) * spread;
              ty = heartCy + (targetHeartY - heartCy) * spread + 55 * k;
              const swirl = (0.006 + 0.012 * (1 - k)) * (p.baseRadius - 0.5);
              const dx = p.x - heartCx;
              const dy = p.y - (heartCy + scale * 6);
              p.vx += -dy * swirl;
              p.vy += dx * swirl;
              p.vy += lerp(-0.14, 0.24, p.scatter) * (0.85 - 0.55 * k);
              p.vy += 0.02 + 0.18 * k;
            }

            const ax = (tx - p.x) * pull;
            const ay = (ty - p.y) * pull;
            p.vx += ax;
            p.vy += ay;
            p.vx *= drag;
            p.vy *= drag;
            p.x += p.vx;
            p.y += p.vy;

            const alpha = particleColorAlpha(p, tMs, ph);
            if (alpha <= 0.001) continue;

            const speed = Math.hypot(p.x - p.px, p.y - p.py);
            if (!prefersReducedMotion && speed > 1.15 && (p.scatter < 0.38 || speed > 2.4)) {
              const len = Math.min(26, speed * 6.4);
              const inv = 1 / (speed || 1);
              const dx = (p.x - p.px) * inv;
              const dy = (p.y - p.py) * inv;
              const a = Math.min(0.55, alpha * (0.055 + speed * 0.018));
              ctx.strokeStyle = `rgba(170, 245, 255, ${a})`;
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(p.x - dx * len, p.y - dy * len);
              ctx.stroke();

              if (speed > 2.35) {
                bloomCtx.strokeStyle = `rgba(150, 240, 255, ${Math.min(
                  0.16,
                  alpha * 0.07 * (speed - 1)
                )})`;
                bloomCtx.lineWidth = 2.8;
                bloomCtx.beginPath();
                bloomCtx.moveTo(p.x, p.y);
                bloomCtx.lineTo(p.x - dx * len, p.y - dy * len);
                bloomCtx.stroke();
              }
            }

            const tw = 0.85 + 0.15 * Math.sin(tMs * 0.007 + p.twinkle);
            const drawSize = p.size * (0.9 + 0.35 * tw);
            const sprite = ph.name === "build" && p.reveal < 0.55 ? spriteDot : spriteHot;
            const s = (sprite.width / 2) * drawSize * 0.35;

            ctx.globalAlpha = Math.min(1, alpha);
            ctx.drawImage(sprite, p.x - s, p.y - s, s * 2, s * 2);

            const bloomA =
              ph.name === "hold" ? alpha * 0.7 : ph.name === "build" ? alpha * 0.55 : alpha * 0.45;
            if (bloomA > 0.035) {
              const hs = (spriteHot.width / 2) * drawSize * 0.62;
              bloomCtx.globalAlpha = Math.min(1, bloomA);
              bloomCtx.drawImage(spriteHot, p.x - hs, p.y - hs, hs * 2, hs * 2);
            }
          }

          bloomCtx.restore();
          ctx.restore();

          ctx.save();
          ctx.globalCompositeOperation = "screen";
          if (!prefersReducedMotion) {
            ctx.globalAlpha = BLOOM.intensity * 0.65;
            ctx.filter = "blur(10px)";
            ctx.drawImage(bloomCanvas, 0, 0, state.w, state.h);
            ctx.filter = "none";
          }
          ctx.globalAlpha = BLOOM.intensity;
          ctx.drawImage(bloomCanvas, 0, 0, state.w, state.h);
          ctx.restore();

          requestAnimationFrame(step);
        }

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, 1, 1);
        requestAnimationFrame(step);
      })();
    </script>
  </body>
</html>
