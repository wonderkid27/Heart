<!doctype html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Heart Particle</title>
    <style>
      :root {
        color-scheme: dark;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
        overflow: hidden;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      #c {
        display: block;
        width: 100vw;
        height: 100vh;
      }

      #errBox {
        position: fixed;
        top: 18px;
        left: 50%;
        transform: translate(-50%, -10px);
        width: min(560px, calc(100vw - 32px));
        box-sizing: border-box;
        padding: 12px 14px;
        border-radius: 14px;
        background: rgba(60, 0, 0, 0.62);
        border: 1px solid rgba(255, 90, 90, 0.9);
        border-left: 6px solid rgba(255, 60, 60, 1);
        color: #fff;
        box-shadow: 0 14px 40px rgba(0, 0, 0, 0.65);
        opacity: 0;
        pointer-events: none;
        z-index: 9999;
        transition: opacity 180ms ease, transform 180ms ease;
        backdrop-filter: blur(10px);
      }
      #errBox.show {
        opacity: 1;
        transform: translate(-50%, 0);
        pointer-events: auto;
      }
      #errBox .row {
        display: flex;
        gap: 12px;
        align-items: flex-start;
      }
      #errBox .icon {
        width: 18px;
        height: 18px;
        margin-top: 2px;
        flex: none;
      }
      #errBox .title {
        font-weight: 700;
        font-size: 14px;
        line-height: 1.15;
        margin: 0 0 4px 0;
      }
      #errBox .msg {
        font-size: 13px;
        line-height: 1.35;
        opacity: 0.9;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>

    <div id="errBox" role="alert" aria-live="assertive" aria-atomic="true">
      <div class="row">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
          <path fill="currentColor" d="M11 7h2v7h-2V7zm0 9h2v2h-2v-2z" />
          <path
            fill="currentColor"
            d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16z"
          />
        </svg>
        <div>
          <div class="title">Lỗi</div>
          <p class="msg">Không thể hoàn tất tạo hình trái tim.</p>
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        const TAU = Math.PI * 2;
        const clamp01 = (v) => Math.max(0, Math.min(1, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const smoothstep = (a, b, t) => {
          const x = clamp01((t - a) / (b - a));
          return x * x * (3 - 2 * x);
        };

        const prefersReducedMotion =
          window.matchMedia &&
          window.matchMedia("(prefers-reduced-motion: reduce)").matches;

        const canvas = document.getElementById("c");
        const errBox = document.getElementById("errBox");
        const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });

        const bgCanvas = document.createElement("canvas");
        const bgCtx = bgCanvas.getContext("2d", { alpha: false, desynchronized: true });

        const bloomCanvas = document.createElement("canvas");
        const bloomCtx = bloomCanvas.getContext("2d", { alpha: true, desynchronized: true });

        const state = {
          w: 0,
          h: 0,
          dpr: 1,
          heartCx: 0,
          heartCy: 0,
          baseCx: 0,
          baseCy: 0,
          scale: 1,
        };
        let requestedReset = true;

        function mulberry32(seed) {
          let a = seed >>> 0;
          return () => {
            a |= 0;
            a = (a + 0x6d2b79f5) | 0;
            let t = Math.imul(a ^ (a >>> 15), 1 | a);
            t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
          };
        }

        const SEED = (Date.now() ^ ((Math.random() * 1e9) | 0)) >>> 0;
        const rng = mulberry32(SEED);

        // Tuned to match `heart.mp4`: black background + subtle bloom (avoid white blowout).
        const BLOOM = {
          down: prefersReducedMotion ? 0.8 : 0.68,
          intensity: prefersReducedMotion ? 0.22 : 0.32,
        };

        function makeGlowSprite(size, inner, mid, outer) {
          const c = document.createElement("canvas");
          c.width = c.height = size;
          const g = c.getContext("2d");
          const r = size / 2;
          const grad = g.createRadialGradient(r, r, 0, r, r, r);
          grad.addColorStop(0, inner);
          grad.addColorStop(0.35, mid);
          grad.addColorStop(1, outer);
          g.fillStyle = grad;
          g.beginPath();
          g.arc(r, r, r, 0, TAU);
          g.fill();
          return c;
        }

        // Smaller / dimmer sprites keep particles visible (like the reference video)
        // instead of becoming a solid glowing blob.
        const spriteDot = makeGlowSprite(
          28,
          "rgba(255, 255, 255, 1)",
          "rgba(160, 240, 255, 0.55)",
          "rgba(0, 150, 220, 0)"
        );
        const spriteHot = makeGlowSprite(
          52,
          "rgba(255, 255, 255, 1)",
          "rgba(140, 235, 255, 0.55)",
          "rgba(0, 140, 210, 0)"
        );

        function heartBoundary(t) {
          const s = Math.sin(t);
          const c = Math.cos(t);
          const x = 16 * s * s * s;
          const y = 13 * c - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
          return { x, y: -y };
        }

        function makeHeartPoints(count) {
          const points = new Array(count);
          for (let i = 0; i < count; i++) {
            const t = rng() * TAU;
            const b = heartBoundary(t);
            const isEdge = rng() < 0.22;
            const u = isEdge ? 0.86 + rng() * 0.14 : Math.sqrt(rng());
            let x = b.x * u;
            let y = b.y * u;
            x += (rng() - 0.5) * 0.75;
            y += (rng() - 0.5) * 0.75;
            points[i] = { x, y };
          }
          return points;
        }

        const PARTICLE_COUNT = prefersReducedMotion ? 900 : 3600;
        const HEART_POINTS = makeHeartPoints(PARTICLE_COUNT);

        // Match the reference clip duration (~20.6s) and pacing.
        const PHASE = {
          cycleMs: prefersReducedMotion ? 14000 : 20600,
          buildMs: prefersReducedMotion ? 3400 : 6000,
          holdMs: prefersReducedMotion ? 6200 : 9800,
          disperseMs: prefersReducedMotion ? 4400 : 4800,
        };


        const ERR_TOAST = {
          triggerK: 0.6,
        };

        let halted = false;

        function setErrorVisible(v) {
          if (!errBox) return;
          errBox.classList.toggle("show", v);
        }

        function haltAll() {
          if (halted) return;
          halted = true;
          setErrorVisible(true);
        }

        function updateErrorToast(tMs, ph) {
          if (halted) return;
          if (ph.name === "build" && ph.k >= ERR_TOAST.triggerK) {
            haltAll();
          }
        }


        function rebuildBackground() {
          const { w, h } = state;
          bgCanvas.width = w;
          bgCanvas.height = h;
          bgCtx.setTransform(1, 0, 0, 1, 0, 0);

          bgCtx.fillStyle = "#000";
          bgCtx.fillRect(0, 0, w, h);
        }

        function computeLayout() {
          const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
          const w = Math.max(1, Math.floor(window.innerWidth));
          const h = Math.max(1, Math.floor(window.innerHeight));
          canvas.width = Math.floor(w * dpr);
          canvas.height = Math.floor(h * dpr);
          canvas.style.width = w + "px";
          canvas.style.height = h + "px";
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          state.w = w;
          state.h = h;
          state.dpr = dpr;
          state.scale = Math.min(w, h) / 58;
          state.heartCx = w * 0.5;
          // Place the heart higher (closer to the reference video framing).
          state.heartCy = h * 0.26;
          state.baseCx = state.heartCx;
          // Energy base sits lower in the reference.
          state.baseCy = h * 0.88;

          bloomCanvas.width = Math.max(1, Math.floor(w * BLOOM.down));
          bloomCanvas.height = Math.max(1, Math.floor(h * BLOOM.down));
          bloomCtx.setTransform(BLOOM.down, 0, 0, BLOOM.down, 0, 0);
          bloomCtx.clearRect(0, 0, w, h);

          rebuildBackground();

          ctx.globalAlpha = 1;
          ctx.globalCompositeOperation = "source-over";
          ctx.drawImage(bgCanvas, 0, 0, w, h);
          requestedReset = true;
        }

        window.addEventListener("resize", () => {
          if (halted) return;
          computeLayout();
        }, { passive: true });
        computeLayout();

        function placeOnBase(p, tMs) {
          const { baseCx, baseCy, scale } = state;
          const ring = scale * 10.5;
          const a = p.baseAngle + tMs * (0.0019 + p.spin * 0.001);
          const r = ring * (0.25 + 0.85 * p.baseRadius);
          p.x = baseCx + Math.cos(a) * r * 2.1;
          p.y = baseCy + Math.sin(a) * r * 0.58;
          p.px = p.x;
          p.py = p.y;
          p.vx = 0;
          p.vy = 0;
        }

        function particleColorAlpha(p, tMs, phase) {
          const tw = 0.7 + 0.3 * Math.sin(tMs * 0.006 + p.twinkle);
          const base = p.brightness * tw;
          if (phase.name === "build") return base * smoothstep(0, 1, phase.k) * p.reveal;
          if (phase.name === "hold") return base;
          return base * (1 - phase.k);
        }

        function phaseAt(tMs) {
          const t = tMs % PHASE.cycleMs;
          const b = PHASE.buildMs;
          const h = PHASE.holdMs;
          const d = PHASE.disperseMs;
          if (t < b) return { name: "build", k: t / b, t };
          if (t < b + h) return { name: "hold", k: (t - b) / h, t };
          return { name: "disperse", k: (t - b - h) / d, t };
        }

        function ensurePhase(phase, tMs) {
          if (phase && typeof phase === "object" && typeof phase.name === "string") return phase;
          const fallback = phaseAt(tMs);
          if (fallback && typeof fallback === "object" && typeof fallback.name === "string") return fallback;
          return { name: "hold", k: 0, t: 0 };
        }

        function makeParticle(i) {
          return {
            i,
            x: 0,
            y: 0,
            px: 0,
            py: 0,
            vx: 0,
            vy: 0,
            size: 0.45 + rng() * 0.95,
            brightness: 0.32 + rng() * 0.6,
            twinkle: rng() * TAU,
            baseAngle: rng() * TAU,
            baseRadius: rng(),
            spin: rng(),
            delay: rng(),
            reveal: 0,
            scatter: rng(),
            wander: rng() * TAU,
          };
        }

        const particles = new Array(PARTICLE_COUNT);
        for (let i = 0; i < particles.length; i++) particles[i] = makeParticle(i);

        function resetCycle(tMs) {
          for (const p of particles) {
            p.delay = Math.pow(rng(), 1.25) * 0.74;
            p.reveal = 0;
            p.scatter = rng();
            p.baseAngle = rng() * TAU;
            p.baseRadius = rng();
            p.wander = rng() * TAU;
            p.vx = 0;
            p.vy = 0;
            placeOnBase(p, tMs);
          }
        }

        resetCycle(0);

        function drawBase(g, tMs, phase, mode = "main") {
          phase = ensurePhase(phase, tMs);
          const { baseCx, baseCy, scale } = state;
          const pulse = 1 + 0.06 * Math.sin(tMs * 0.0022);
          const r = scale * (mode === "bloom" ? 12.2 : 11.1) * pulse;

          const intensity = phase.name === "disperse" ? 1 - phase.k * 0.65 : 1;
          const gain = mode === "bloom" ? 1.25 : 1;

          g.save();
          g.globalCompositeOperation = "lighter";

          g.save();
          g.translate(baseCx, baseCy);
          g.scale(2.35, 0.75);
          const grad = g.createRadialGradient(0, 0, 0, 0, 0, r);
          grad.addColorStop(0, `rgba(210, 255, 255, ${0.55 * intensity * gain})`);
          grad.addColorStop(0.24, `rgba(130, 242, 255, ${0.26 * intensity * gain})`);
          grad.addColorStop(0.78, `rgba(40, 200, 255, ${0.08 * intensity * gain})`);
          grad.addColorStop(1, "rgba(0, 0, 0, 0)");
          g.fillStyle = grad;
          g.beginPath();
          g.arc(0, 0, r, 0, TAU);
          g.fill();
          g.restore();

          const ringCount = prefersReducedMotion ? 8 : mode === "bloom" ? 10 : 18;
          const ringAlpha = (mode === "bloom" ? 0.06 : 0.05) * (1 - phase.k * 0.35);
          g.lineCap = "round";
          for (let i = 0; i < ringCount; i++) {
            const a0 = tMs * 0.00125 + (i / ringCount) * TAU;
            const a1 = a0 + (0.35 + 0.45 * Math.sin(tMs * 0.0015 + i)) * 0.92;
            const rr = r * (1.12 + 0.24 * Math.sin(i * 9.2 + tMs * 0.001));
            g.strokeStyle = `rgba(160, 245, 255, ${ringAlpha})`;
            g.lineWidth = mode === "bloom" ? 1.8 : 1.0;
            g.beginPath();
            g.ellipse(baseCx, baseCy, rr * 2.1, rr * 0.62, 0, a0, a1);
            g.stroke();
          }

          g.restore();
        }

        function drawThreads(g, tMs, phase, mode = "main") {
          if (prefersReducedMotion) return;
          phase = ensurePhase(phase, tMs);
          const { baseCx, baseCy, heartCx, heartCy, scale } = state;

          const intensity =
            phase.name === "build"
              ? smoothstep(0.08, 1, phase.k)
              : phase.name === "hold"
              ? 0.55
              : (1 - phase.k) * 0.42;
          if (intensity <= 0.001) return;

          const count = mode === "bloom" ? 8 : 12;
          const rx = scale * 22;
          const ry = scale * 6.7;

          g.save();
          g.globalCompositeOperation = "lighter";
          g.lineCap = "round";
          g.lineJoin = "round";
          for (let i = 0; i < count; i++) {
            const a = tMs * 0.00125 + i * 1.72;
            const sx = baseCx + Math.cos(a) * rx;
            const sy = baseCy + Math.sin(a) * ry;
            const ex = heartCx + Math.sin(a * 0.72) * scale * 6.5;
            const ey = heartCy + Math.cos(a * 0.94) * scale * 4.2;
            const wob = Math.sin(a * 2.35 + tMs * 0.002) * scale * 10.5;
            const lift = scale * (18 + 10 * Math.sin(a + tMs * 0.003));
            const cxp = (sx + ex) * 0.5 + wob;
            const cyp = (sy + ey) * 0.5 - lift;
            const flick = 0.45 + 0.55 * Math.sin(i * 12.3 + tMs * 0.003);
            const aLine = (mode === "bloom" ? 0.045 : 0.03) * intensity * (0.55 + 0.45 * flick);
            g.strokeStyle = `rgba(180, 250, 255, ${aLine})`;
            g.lineWidth = mode === "bloom" ? 2.1 : 1.0;
            g.beginPath();
            g.moveTo(sx, sy);
            g.quadraticCurveTo(cxp, cyp, ex, ey);
            g.stroke();
          }
          g.restore();
        }

        function backgroundFade(phase, tMs) {
          phase = ensurePhase(phase, tMs);
          ctx.globalCompositeOperation = "source-over";
          let a =
            phase.name === "build"
              ? lerp(0.28, 0.18, phase.k)
              : phase.name === "hold"
              ? 0.16
              : lerp(0.16, 0.28, phase.k);
          if (phase.name === "disperse") a += smoothstep(0.72, 1, phase.k) * 0.18;
          ctx.globalAlpha = a;
          ctx.drawImage(bgCanvas, 0, 0, state.w, state.h);
          ctx.globalAlpha = 1;
        }

        let lastT = 0;
        let paused = false;
        let pauseAt = 0;
        let startAt = performance.now();
        let rafId = 0;

        window.addEventListener("keydown", (e) => {
          if (halted) return;
          if (e.code !== "Space") return;
          e.preventDefault();
          paused = !paused;
          if (paused) pauseAt = performance.now();
          else startAt += performance.now() - pauseAt;
        });

        function step(now) {
          if (halted) return;
          if (paused) {
            rafId = requestAnimationFrame(step);
            return;
          }

          const tMs = now - startAt;
          const ph = ensurePhase(phaseAt(tMs), tMs);
          if (requestedReset) {
            resetCycle(tMs);
            requestedReset = false;
            lastT = ph.t;
          } else if (ph.t < lastT) {
            resetCycle(tMs);
          }
          lastT = ph.t;

          updateErrorToast(tMs, ph);
          if (halted) return;

          backgroundFade(ph, tMs);
          bloomCtx.globalCompositeOperation = "source-over";
          const bloomFade = ph.name === "hold" ? 0.36 : ph.name === "build" ? 0.32 : 0.42;
          bloomCtx.fillStyle = `rgba(0,0,0,${bloomFade})`;
          bloomCtx.fillRect(0, 0, state.w, state.h);

          drawBase(ctx, tMs, ph, "main");
          drawThreads(ctx, tMs, ph, "main");
          drawBase(bloomCtx, tMs, ph, "bloom");
          drawThreads(bloomCtx, tMs, ph, "bloom");

          const { heartCx, heartCy, baseCx, baseCy, scale } = state;
          const pulse = 1 + 0.03 * Math.sin(tMs * 0.0027);
          const heartScale = scale * pulse;
          const rot = tMs * 0.000085 + 0.08 * Math.sin(tMs * 0.0007);
          const cr = Math.cos(rot);
          const sr = Math.sin(rot);

          const pull =
            ph.name === "build" ? 0.018 : ph.name === "hold" ? 0.012 : lerp(0.01, 0.002, ph.k);
          const drag = ph.name === "disperse" ? lerp(0.88, 0.96, ph.k) : 0.86;

          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          bloomCtx.save();
          bloomCtx.globalCompositeOperation = "lighter";

          for (const p of particles) {
            p.px = p.x;
            p.py = p.y;

            const pt = HEART_POINTS[p.i];
            const hx = pt.x * cr - pt.y * sr;
            const hy = pt.x * sr + pt.y * cr;
            const targetHeartX = heartCx + hx * heartScale;
            const targetHeartY = heartCy + hy * heartScale;

            let tx = targetHeartX;
            let ty = targetHeartY;

            if (ph.name === "build") {
              const emit = smoothstep(0, 1, (ph.k - p.delay) / 0.35);
              p.reveal = emit;

              if (emit < 0.02) {
                const ring = scale * 10.5;
                const a = p.baseAngle + tMs * (0.0019 + p.spin * 0.001);
                const r = ring * (0.25 + 0.85 * p.baseRadius);
                tx = baseCx + Math.cos(a) * r * 2.1;
                ty = baseCy + Math.sin(a) * r * 0.58;
              } else {
                const jet = 1 - smoothstep(0, 1, (ph.k - p.delay) / 0.22);
                p.vy -= jet * (0.75 + p.baseRadius * 0.8);
                p.vx += Math.sin(p.wander + tMs * 0.004) * jet * 0.35;
              }
            } else if (ph.name === "disperse") {
              const k = ph.k;
              const spread = 1 + 1.7 * k * k;
              tx = heartCx + (targetHeartX - heartCx) * spread;
              ty = heartCy + (targetHeartY - heartCy) * spread + 55 * k;
              const swirl = (0.006 + 0.012 * (1 - k)) * (p.baseRadius - 0.5);
              const dx = p.x - heartCx;
              const dy = p.y - (heartCy + scale * 6);
              p.vx += -dy * swirl;
              p.vy += dx * swirl;
              p.vy += lerp(-0.14, 0.24, p.scatter) * (0.85 - 0.55 * k);
              p.vy += 0.02 + 0.18 * k;
            }

            const ax = (tx - p.x) * pull;
            const ay = (ty - p.y) * pull;
            p.vx += ax;
            p.vy += ay;
            p.vx *= drag;
            p.vy *= drag;
            p.x += p.vx;
            p.y += p.vy;

            const alpha = particleColorAlpha(p, tMs, ph);
            if (alpha <= 0.001) continue;

            const speed = Math.hypot(p.x - p.px, p.y - p.py);
            if (!prefersReducedMotion && speed > 1.15 && (p.scatter < 0.38 || speed > 2.35)) {
              const len = Math.min(86, speed * 14);
              const inv = 1 / (speed || 1);
              const dx = (p.x - p.px) * inv;
              const dy = (p.y - p.py) * inv;
              const a = Math.min(0.35, alpha * (0.04 + speed * 0.012));
              ctx.strokeStyle = `rgba(170, 245, 255, ${a})`;
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(p.x - dx * len, p.y - dy * len);
              ctx.stroke();

              if (speed > 2.2) {
                bloomCtx.strokeStyle = `rgba(150, 240, 255, ${Math.min(
                  0.12,
                  alpha * 0.05 * (speed - 1)
                )})`;
                bloomCtx.lineWidth = 2.4;
                bloomCtx.beginPath();
                bloomCtx.moveTo(p.x, p.y);
                bloomCtx.lineTo(p.x - dx * len, p.y - dy * len);
                bloomCtx.stroke();
              }
            }

            const tw = 0.85 + 0.15 * Math.sin(tMs * 0.007 + p.twinkle);
            const drawSize = p.size * (0.9 + 0.35 * tw);
            const sprite = ph.name === "build" && p.reveal < 0.55 ? spriteDot : spriteHot;
            const s = (sprite.width / 2) * drawSize * 0.16;

            ctx.globalAlpha = Math.min(1, alpha * 0.75);
            ctx.drawImage(sprite, p.x - s, p.y - s, s * 2, s * 2);

            const bloomA =
              ph.name === "hold" ? alpha * 0.5 : ph.name === "build" ? alpha * 0.4 : alpha * 0.34;
            if (bloomA > 0.03) {
              const hs = (spriteHot.width / 2) * drawSize * 0.28;
              bloomCtx.globalAlpha = Math.min(1, bloomA);
              bloomCtx.drawImage(spriteHot, p.x - hs, p.y - hs, hs * 2, hs * 2);
            }
          }

          bloomCtx.restore();
          ctx.restore();

          ctx.save();
          ctx.globalCompositeOperation = "screen";
          if (!prefersReducedMotion) {
            ctx.globalAlpha = BLOOM.intensity * 0.55;
            ctx.filter = "blur(7px)";
            ctx.drawImage(bloomCanvas, 0, 0, state.w, state.h);
            ctx.filter = "none";
          }
          ctx.globalAlpha = BLOOM.intensity;
          ctx.drawImage(bloomCanvas, 0, 0, state.w, state.h);
          ctx.restore();

          rafId = requestAnimationFrame(step);
        }

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, 1, 1);
        rafId = requestAnimationFrame(step);
      })();
    </script>
  </body>
</html>
