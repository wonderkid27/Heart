<!doctype html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Heart Particle</title>
    <style>
      :root {
        color-scheme: dark;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
        overflow: hidden;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      #c {
        display: block;
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <script>
      (() => {
        "use strict";

        const TAU = Math.PI * 2;
        const FRAME_MS = 1000 / 60;
        const clamp01 = (v) => Math.max(0, Math.min(1, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const smoothstep = (a, b, t) => {
          const x = clamp01((t - a) / (b - a));
          return x * x * (3 - 2 * x);
        };

        const prefersReducedMotion =
          window.matchMedia &&
          window.matchMedia("(prefers-reduced-motion: reduce)").matches;

        const canvas = document.getElementById("c");
        const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });

        const bgCanvas = document.createElement("canvas");
        const bgCtx = bgCanvas.getContext("2d", { alpha: false, desynchronized: true });

        const bloomCanvas = document.createElement("canvas");
        const bloomCtx = bloomCanvas.getContext("2d", { alpha: true, desynchronized: true });

        const state = {
          w: 0,
          h: 0,
          dpr: 1,
          heartCx: 0,
          heartCy: 0,
          baseCx: 0,
          baseCy: 0,
          scale: 1,
        };
        let requestedReset = true;

        function mulberry32(seed) {
          let a = seed >>> 0;
          return () => {
            a |= 0;
            a = (a + 0x6d2b79f5) | 0;
            let t = Math.imul(a ^ (a >>> 15), 1 | a);
            t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
          };
        }

        const getNumberParam = (key) => {
          try {
            const sp = new URLSearchParams(window.location.search);
            const v = sp.get(key);
            if (v == null || v === "") return null;
            const n = Number(v);
            return Number.isFinite(n) ? n : null;
          } catch {
            return null;
          }
        };

        const seedFromUrl = getNumberParam("seed");
        const SEED =
          seedFromUrl == null ? ((Date.now() ^ ((Math.random() * 1e9) | 0)) >>> 0) : (seedFromUrl >>> 0);
        const rng = mulberry32(SEED);

        const FORCE_W = getNumberParam("w");
        const FORCE_H = getNumberParam("h");

        // Tuned to match `heart.mp4`: black background + subtle bloom (avoid white blowout).
        const BLOOM = {
          down: prefersReducedMotion ? 0.8 : 0.76,
          intensity: prefersReducedMotion ? 0.18 : 0.26,
        };

        function makeGlowSprite(size, inner, mid, outer) {
          const c = document.createElement("canvas");
          c.width = c.height = size;
          const g = c.getContext("2d");
          const r = size / 2;
          const grad = g.createRadialGradient(r, r, 0, r, r, r);
          grad.addColorStop(0, inner);
          grad.addColorStop(0.35, mid);
          grad.addColorStop(1, outer);
          g.fillStyle = grad;
          g.beginPath();
          g.arc(r, r, r, 0, TAU);
          g.fill();
          return c;
        }

        // Smaller / dimmer sprites keep particles visible (like the reference video)
        // instead of becoming a solid glowing blob.
        const spriteDot = makeGlowSprite(
          34,
          "rgba(245, 255, 255, 1)",
          "rgba(150, 240, 255, 0.66)",
          "rgba(0, 165, 245, 0)"
        );
        const spriteHot = makeGlowSprite(
          64,
          "rgba(255, 255, 255, 1)",
          "rgba(140, 235, 255, 0.72)",
          "rgba(0, 155, 235, 0)"
        );

        function heartBoundary(t) {
          const s = Math.sin(t);
          const c = Math.cos(t);
          const x = 16 * s * s * s;
          const y = 13 * c - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
          return { x, y: -y };
        }

        function makeHeartPoints(count) {
          const points = new Array(count);
          for (let i = 0; i < count; i++) {
            const t = rng() * TAU;
            const b = heartBoundary(t);
            const isEdge = rng() < 0.22;
            const u = isEdge ? 0.86 + rng() * 0.14 : Math.sqrt(rng());
            let x = b.x * u;
            let y = b.y * u;
            x += (rng() - 0.5) * 0.75;
            y += (rng() - 0.5) * 0.75;
            points[i] = { x, y };
          }
          return points;
        }

        const PARTICLE_COUNT = prefersReducedMotion ? 1400 : 5000;
        const HEART_POINTS = makeHeartPoints(PARTICLE_COUNT);

        // Timeline tuned to match `heart.mp4` (~20.6s).
        const PHASE = {
          introMs: prefersReducedMotion ? 700 : 500, // faint heart
          cloudMs: prefersReducedMotion ? 1900 : 2500, // mushroom / rain
          reformMs: prefersReducedMotion ? 700 : 700, // heart returns + base appears
          rampMs: prefersReducedMotion ? 3200 : 4800, // brightening heart
          surgeMs: prefersReducedMotion ? 4200 : 6500, // energetic streaks/threads
          stableMs: prefersReducedMotion ? 4000 : 5600, // stable heart
        };
        PHASE.cycleMs =
          PHASE.introMs +
          PHASE.cloudMs +
          PHASE.reformMs +
          PHASE.rampMs +
          PHASE.surgeMs +
          PHASE.stableMs;

        function rebuildBackground() {
          const { w, h } = state;
          bgCanvas.width = w;
          bgCanvas.height = h;
          bgCtx.setTransform(1, 0, 0, 1, 0, 0);

          bgCtx.fillStyle = "#000";
          bgCtx.fillRect(0, 0, w, h);
        }

        function computeLayout() {
          const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
          const w = Math.max(1, Math.floor(FORCE_W != null ? FORCE_W : window.innerWidth));
          const h = Math.max(1, Math.floor(FORCE_H != null ? FORCE_H : window.innerHeight));
          canvas.width = Math.floor(w * dpr);
          canvas.height = Math.floor(h * dpr);
          canvas.style.width = w + "px";
          canvas.style.height = h + "px";
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          state.w = w;
          state.h = h;
          state.dpr = dpr;
          state.scale = Math.min(w, h) / 55;
          state.heartCx = w * 0.5;
          // Reference framing: heart sits above the base, base near the bottom.
          state.heartCy = h * 0.44;
          state.baseCx = state.heartCx;
          // Energy base sits lower in the reference.
          state.baseCy = h * 0.87;

          bloomCanvas.width = Math.max(1, Math.floor(w * BLOOM.down));
          bloomCanvas.height = Math.max(1, Math.floor(h * BLOOM.down));
          bloomCtx.setTransform(BLOOM.down, 0, 0, BLOOM.down, 0, 0);
          bloomCtx.clearRect(0, 0, w, h);

          rebuildBackground();

          ctx.globalAlpha = 1;
          ctx.globalCompositeOperation = "source-over";
          ctx.drawImage(bgCanvas, 0, 0, w, h);
          requestedReset = true;
        }

        window.addEventListener("resize", computeLayout, { passive: true });
        computeLayout();

        function placeOnBase(p, tMs) {
          const { baseCx, baseCy, scale } = state;
          const ring = scale * 10.5;
          const a = p.baseAngle + tMs * (0.0019 + p.spin * 0.001);
          const r = ring * (0.25 + 0.85 * p.baseRadius);
          p.x = baseCx + Math.cos(a) * r * 2.1;
          p.y = baseCy + Math.sin(a) * r * 0.58;
          p.px = p.x;
          p.py = p.y;
          p.vx = 0;
          p.vy = 0;
        }

        function groundTarget(p, tMs) {
          const { baseCx, baseCy, scale, w } = state;
          const spreadX = w * 0.42;
          const y0 = baseCy - scale * 5.0;
          const wob = Math.sin(tMs * 0.0012 + p.wander) * scale * 0.35;
          const x = baseCx + p.groundX * spreadX + wob;
          const y = y0 + (p.groundY - 0.5) * scale * 2.2 + Math.cos(tMs * 0.001 + p.twinkle) * 0.4;
          return { x, y };
        }

        function placeOnGround(p, tMs) {
          const g = groundTarget(p, tMs);
          p.x = g.x;
          p.y = g.y;
          p.px = p.x;
          p.py = p.y;
          p.vx = 0;
          p.vy = 0;
        }

        function cloudTarget(p) {
          const { baseCx, baseCy, scale, w, h } = state;
          const capCx = baseCx;
          const capCy = h * 0.18;
          const capRx = w * 0.22;
          const capRy = h * 0.20;
          const groundY = baseCy - scale * 5.0;

          // Some particles form a rain-like column down to the base.
          if (p.cloudRole < 0.28) {
            const x = baseCx + p.cloudX * scale * 7.0;
            const y = lerp(capCy + capRy * 0.25, groundY, p.cloudY);
            return { x, y };
          }

          const x = capCx + p.cloudX * capRx;
          const y = capCy + (p.cloudY - 0.5) * capRy * 2.0;
          return { x, y };
        }

        function phaseGain(phase) {
          switch (phase.name) {
            case "intro":
              return 0.5;
            case "cloud":
              return lerp(0.7, 1.0, smoothstep(0, 1, phase.k));
            case "reform":
              return lerp(0.8, 0.95, smoothstep(0, 1, phase.k));
            case "ramp":
              return lerp(0.9, 1.25, smoothstep(0, 1, phase.k));
            case "surge":
              return 1.45;
            case "stable":
              return lerp(1.2, 1.0, smoothstep(0, 1, phase.k));
            default:
              return 0.8;
          }
        }

        function particleColorAlpha(p, tMs, phase) {
          phase = ensurePhase(phase, tMs);
          const tw = 0.7 + 0.3 * Math.sin(tMs * 0.006 + p.twinkle);
          let gain = phaseGain(phase);
          if (p.role === "ground") gain *= 0.9;
          return p.brightness * tw * gain;
        }

        function phaseAt(tMs) {
          const t = ((tMs % PHASE.cycleMs) + PHASE.cycleMs) % PHASE.cycleMs;
          const t1 = PHASE.introMs;
          const t2 = t1 + PHASE.cloudMs;
          const t3 = t2 + PHASE.reformMs;
          const t4 = t3 + PHASE.rampMs;
          const t5 = t4 + PHASE.surgeMs;
          if (t < t1) return { name: "intro", k: t / PHASE.introMs, t };
          if (t < t2) return { name: "cloud", k: (t - t1) / PHASE.cloudMs, t };
          if (t < t3) return { name: "reform", k: (t - t2) / PHASE.reformMs, t };
          if (t < t4) return { name: "ramp", k: (t - t3) / PHASE.rampMs, t };
          if (t < t5) return { name: "surge", k: (t - t4) / PHASE.surgeMs, t };
          return { name: "stable", k: (t - t5) / PHASE.stableMs, t };
        }

        function ensurePhase(phase, tMs) {
          if (phase && typeof phase === "object" && typeof phase.name === "string") return phase;
          const fallback = phaseAt(tMs);
          if (fallback && typeof fallback === "object" && typeof fallback.name === "string") return fallback;
          return { name: "stable", k: 0, t: 0 };
        }

        function makeParticle(i) {
          const role = rng() < 0.3 ? "ground" : "heart";
          const cloudX = (rng() + rng() + rng() + rng() - 2) * 0.85; // ~normal-ish
          const cloudY = (rng() + rng()) * 0.5; // peaked around 0.5
          return {
            i,
            role,
            x: 0,
            y: 0,
            px: 0,
            py: 0,
            vx: 0,
            vy: 0,
            size: 0.5 + rng() * 0.9,
            brightness: 0.1 + rng() * 0.26,
            twinkle: rng() * TAU,
            baseAngle: rng() * TAU,
            baseRadius: rng(),
            spin: rng(),
            delay: rng(),
            reveal: 0,
            scatter: rng(),
            wander: rng() * TAU,
            cloudRole: rng(),
            cloudX,
            cloudY,
            groundX: rng() * 2 - 1,
            groundY: rng(),
            spark: rng(),
          };
        }

        const particles = new Array(PARTICLE_COUNT);
        for (let i = 0; i < particles.length; i++) particles[i] = makeParticle(i);

        function heartRotation(tMs) {
          // Subtle wobble like the reference (avoid continuous spinning).
          return 0.03 * Math.sin(tMs * 0.0007);
        }

        function placeOnHeart(p, tMs) {
          const { heartCx, heartCy, scale } = state;
          const pulse = 1 + 0.03 * Math.sin(tMs * 0.0027);
          const heartScale = scale * pulse;
          const rot = heartRotation(tMs);
          const cr = Math.cos(rot);
          const sr = Math.sin(rot);
          const pt = HEART_POINTS[p.i];
          const hx = pt.x * cr - pt.y * sr;
          const hy = pt.x * sr + pt.y * cr;
          p.x = heartCx + hx * heartScale;
          p.y = heartCy + hy * heartScale;
          p.px = p.x;
          p.py = p.y;
          p.vx = 0;
          p.vy = 0;
        }

        function resetCycle(tMs) {
          for (const p of particles) {
            p.delay = Math.pow(rng(), 1.25) * 0.74;
            p.reveal = 1;
            p.scatter = rng();
            p.baseAngle = rng() * TAU;
            p.baseRadius = rng();
            p.wander = rng() * TAU;
            p.vx = 0;
            p.vy = 0;
            if (p.role === "ground") placeOnGround(p, tMs);
            else placeOnHeart(p, tMs);
          }
        }

        function drawBase(g, tMs, phase, mode = "main") {
          phase = ensurePhase(phase, tMs);
          const { baseCx, baseCy, scale } = state;
          const pulse = 1 + 0.07 * Math.sin(tMs * 0.0022);
          const r = scale * (mode === "bloom" ? 10.8 : 9.9) * pulse;

          const vis = (() => {
            switch (phase.name) {
              case "intro":
                return 0;
              case "cloud":
                return lerp(0.18, 0.45, smoothstep(0, 1, phase.k));
              case "reform":
                return lerp(0.12, 0.8, smoothstep(0.2, 1, phase.k));
              case "ramp":
                return lerp(0.85, 1.05, smoothstep(0, 1, phase.k));
              case "surge":
                return 1.2;
              case "stable":
                return lerp(1.0, 0.85, smoothstep(0, 1, phase.k));
              default:
                return 0.7;
            }
          })();
          const gain = mode === "bloom" ? 1.15 : 1;
          if (vis <= 0.001) return;

          g.save();
          g.globalCompositeOperation = "lighter";

          g.save();
          g.translate(baseCx, baseCy);
          g.scale(2.35, 0.75);
          const grad = g.createRadialGradient(0, 0, 0, 0, 0, r);
          grad.addColorStop(0, `rgba(210, 255, 255, ${0.4 * vis * gain})`);
          grad.addColorStop(0.24, `rgba(120, 235, 255, ${0.18 * vis * gain})`);
          grad.addColorStop(0.72, `rgba(40, 200, 255, ${0.06 * vis * gain})`);
          grad.addColorStop(1, "rgba(0, 0, 0, 0)");
          g.fillStyle = grad;
          g.beginPath();
          g.arc(0, 0, r, 0, TAU);
          g.fill();
          g.restore();

          const sweepAlpha = (mode === "bloom" ? 0.14 : 0.1) * vis;
          const sweep = tMs * 0.0013;
          g.strokeStyle = `rgba(200, 255, 255, ${sweepAlpha})`;
          g.lineWidth = mode === "bloom" ? 2.5 : 1.7;
          g.beginPath();
          g.ellipse(baseCx, baseCy, r * 2.1, r * 0.64, 0, sweep, sweep + 2.1);
          g.stroke();

          const ringCount = prefersReducedMotion ? 6 : mode === "bloom" ? 10 : 16;
          const ringAlpha = (mode === "bloom" ? 0.065 : 0.05) * vis;
          g.lineCap = "round";
          for (let i = 0; i < ringCount; i++) {
            const a0 = tMs * 0.00125 + (i / ringCount) * TAU;
            const a1 = a0 + (0.35 + 0.45 * Math.sin(tMs * 0.0015 + i)) * 0.98;
            const rr = r * (1.06 + 0.24 * Math.sin(i * 9.2 + tMs * 0.001));
            g.strokeStyle = `rgba(160, 245, 255, ${ringAlpha})`;
            g.lineWidth = mode === "bloom" ? 2.1 : 1.2;
            g.beginPath();
            g.ellipse(baseCx, baseCy, rr * 2.1, rr * 0.64, 0, a0, a1);
            g.stroke();
          }

          g.restore();
        }

        function drawThreads(g, tMs, phase, mode = "main") {
          if (prefersReducedMotion) return;
          phase = ensurePhase(phase, tMs);
          const { baseCx, baseCy, heartCx, heartCy, scale } = state;

          const intensity = (() => {
            switch (phase.name) {
              case "surge":
                return 1.1;
              case "ramp":
                return lerp(0.2, 0.5, smoothstep(0.25, 1, phase.k));
              case "stable":
                return lerp(0.55, 0.3, smoothstep(0, 1, phase.k));
              default:
                return 0;
            }
          })();
          if (intensity <= 0.001) return;

          const count = mode === "bloom" ? 10 : 15;
          const rx = scale * 24;
          const ry = scale * 7.5;

          g.save();
          g.globalCompositeOperation = "lighter";
          g.lineCap = "round";
          g.lineJoin = "round";
          for (let i = 0; i < count; i++) {
            const a = tMs * 0.00125 + i * 1.72;
            const sx = baseCx + Math.cos(a) * rx;
            const sy = baseCy + Math.sin(a) * ry;
            const ex = heartCx + Math.sin(a * 0.72) * scale * 6.5;
            const ey = heartCy + Math.cos(a * 0.94) * scale * 4.2;
            const wob = Math.sin(a * 2.35 + tMs * 0.002) * scale * 10.5;
            const lift = scale * (18 + 10 * Math.sin(a + tMs * 0.003));
            const cxp = (sx + ex) * 0.5 + wob;
            const cyp = (sy + ey) * 0.5 - lift;
            const flick = 0.45 + 0.55 * Math.sin(i * 12.3 + tMs * 0.003);
            const aLine = (mode === "bloom" ? 0.07 : 0.05) * intensity * (0.6 + 0.4 * flick);
            g.strokeStyle = `rgba(180, 250, 255, ${aLine})`;
            g.lineWidth = mode === "bloom" ? 2.6 : 1.3;
            g.beginPath();
            g.moveTo(sx, sy);
            g.quadraticCurveTo(cxp, cyp, ex, ey);
            g.stroke();
          }
          g.restore();
        }

        function backgroundFade(phase, tMs) {
          phase = ensurePhase(phase, tMs);
          ctx.globalCompositeOperation = "source-over";
          const a = (() => {
            switch (phase.name) {
              case "intro":
                return lerp(0.32, 0.26, smoothstep(0, 1, phase.k));
              case "cloud":
                return lerp(0.24, 0.18, smoothstep(0, 1, phase.k));
              case "reform":
                return lerp(0.22, 0.26, smoothstep(0, 1, phase.k));
              case "ramp":
                return lerp(0.22, 0.18, smoothstep(0, 1, phase.k));
              case "surge":
                return 0.14;
              case "stable":
                return lerp(0.2, 0.24, smoothstep(0, 1, phase.k));
              default:
                return 0.22;
            }
          })();
          ctx.globalAlpha = a;
          ctx.drawImage(bgCanvas, 0, 0, state.w, state.h);
          ctx.globalAlpha = 1;
        }

        let lastT = 0;
        let lastNow = null;
        let paused = false;
        let pauseAt = 0;
        let lastPhaseName = "";
        let warmedUp = false;
        const STILL_FRAME = (() => {
          const v = getNumberParam("still");
          return v != null && v !== 0;
        })();

        const START_OFFSET_MS = (() => {
          const parseMs = (v) => {
            const n = Number(v);
            return Number.isFinite(n) ? Math.max(0, n) : 0;
          };
          const fromQuery = getNumberParam("t");
          if (fromQuery != null) return parseMs(fromQuery);
          const m = /t=(\d+)/.exec(window.location.hash || "");
          if (m) return parseMs(m[1]);
          return 0;
        })();

        let startAt = null;

        window.addEventListener("keydown", (e) => {
          if (e.code !== "Space") return;
          e.preventDefault();
          const now = performance.now();
          if (startAt == null) startAt = now - START_OFFSET_MS;
          paused = !paused;
          if (paused) pauseAt = now;
          else {
            startAt += now - pauseAt;
            lastNow = now;
          }
        });

        function clampDtFrames(dt) {
          if (!Number.isFinite(dt)) return 1;
          return Math.max(0, Math.min(2.5, dt));
        }

        function phaseEnterImpulse(ph) {
          if (ph.name === "cloud") {
            for (const p of particles) {
              if (p.role !== "heart") continue;
              p.vx += (p.cloudX * 0.6 + (p.scatter - 0.5) * 0.4) * 2.4;
              p.vy -= (1.6 + p.baseRadius * 1.8) * 2.6;
            }
          } else if (ph.name === "surge") {
            for (const p of particles) {
              if (p.role !== "heart") continue;
              p.vx += Math.sin(p.wander) * (0.8 + p.scatter) * 2.0;
              p.vy -= (0.8 + p.baseRadius) * 2.0;
            }
          }
        }

        function advanceParticles(tMs, dtFrames, ph, draw) {
          const dt = clampDtFrames(dtFrames);

          if (ph.name !== lastPhaseName) {
            phaseEnterImpulse(ph);
            lastPhaseName = ph.name;
          }

          const pull = (() => {
            switch (ph.name) {
              case "intro":
                return 0.02;
              case "cloud":
                return 0.012;
              case "reform":
                return lerp(0.022, 0.032, smoothstep(0, 1, ph.k));
              case "ramp":
                return 0.022;
              case "surge":
                return lerp(0.012, 0.009, smoothstep(0, 1, ph.k));
              case "stable":
                return 0.02;
              default:
                return 0.018;
            }
          })();

          const drag = (() => {
            switch (ph.name) {
              case "cloud":
                return 0.9;
              case "surge":
                return 0.9;
              default:
                return 0.86;
            }
          })();
          const dragPow = Math.pow(drag, dt);

          const streakCfg = (() => {
            switch (ph.name) {
              case "surge":
                return { minSpeed: 0.8, lenMul: 20, maxLen: 150, alphaMul: 1.45 };
              case "cloud":
                return { minSpeed: 1.0, lenMul: 17, maxLen: 120, alphaMul: 1.25 };
              default:
                return { minSpeed: 1.25, lenMul: 15, maxLen: 95, alphaMul: 1.1 };
            }
          })();

          const { heartCx, heartCy, baseCx, baseCy, scale } = state;
          const pulse = 1 + 0.03 * Math.sin(tMs * 0.0027);
          const heartScale = scale * pulse;
          const rot = heartRotation(tMs);
          const cr = Math.cos(rot);
          const sr = Math.sin(rot);

          if (draw) {
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            bloomCtx.save();
            bloomCtx.globalCompositeOperation = "lighter";
          }

          const invDt = 1 / Math.max(0.0001, dt);

          for (const p of particles) {
            p.px = p.x;
            p.py = p.y;

            const pt = HEART_POINTS[p.i];
            const hx = pt.x * cr - pt.y * sr;
            const hy = pt.x * sr + pt.y * cr;
            const targetHeartX = heartCx + hx * heartScale;
            const targetHeartY = heartCy + hy * heartScale;

            let tx = targetHeartX;
            let ty = targetHeartY;

            if (p.role === "ground") {
              const g = groundTarget(p, tMs);
              tx = g.x;
              ty = g.y;
            } else if (ph.name === "cloud") {
              const k = ph.k;
              const cloud = cloudTarget(p);
              const mix = smoothstep(0, 0.22, k);
              tx = lerp(targetHeartX, cloud.x, mix);
              ty = lerp(targetHeartY, cloud.y, mix);

              const swirl = (0.004 + 0.012 * (1 - k)) * (p.baseRadius - 0.5);
              const dx = p.x - heartCx;
              const dy = p.y - (heartCy + scale * 3);
              p.vx += -dy * swirl * dt;
              p.vy += dx * swirl * dt;

              const lift = (1 - smoothstep(0.15, 1, k)) * (0.24 + 0.26 * (1 - p.cloudY));
              p.vy -= lift * (0.9 + p.baseRadius * 0.8) * dt;
              p.vx += Math.sin(p.wander + tMs * 0.003) * lift * 0.55 * dt;
              p.vy += (0.06 + 0.12 * k) * dt; // rain/gravity
            } else if (ph.name === "reform") {
              const k = ph.k;
              const cloud = cloudTarget(p);
              const mix = 1 - smoothstep(0, 0.7, k);
              tx = lerp(targetHeartX, cloud.x, mix);
              ty = lerp(targetHeartY, cloud.y, mix);
              p.vy += 0.04 * dt;
            } else if (ph.name === "surge") {
              const k = ph.k;
              const swell = 1 + 0.12 * Math.sin(tMs * 0.0014) * (0.6 + 0.4 * (1 - k));
              tx = heartCx + (targetHeartX - heartCx) * swell;
              ty = heartCy + (targetHeartY - heartCy) * swell;

              const swirl = (0.01 + 0.016 * (1 - k)) * (p.baseRadius - 0.5);
              const dx = p.x - heartCx;
              const dy = p.y - (heartCy + scale * 4);
              p.vx += -dy * swirl * dt;
              p.vy += dx * swirl * dt;

              const burst = smoothstep(0.86, 1, Math.sin(tMs * 0.006 + p.wander * 1.7));
              const jet = burst * (0.2 + 0.8 * (1 - k)) * (p.spark < 0.18 ? 1 : 0.35);
              p.vy -= jet * (1.2 + p.baseRadius * 1.6) * dt;
              p.vx += Math.cos(p.wander + tMs * 0.002) * jet * 0.9 * dt;
              p.vy += (0.05 + 0.08 * k) * dt;
            }

            const ax = (tx - p.x) * pull;
            const ay = (ty - p.y) * pull;
            p.vx += ax * dt;
            p.vy += ay * dt;
            p.vx *= dragPow;
            p.vy *= dragPow;
            p.x += p.vx * dt;
            p.y += p.vy * dt;

            if (!draw) continue;

            const alpha = particleColorAlpha(p, tMs, ph);
            if (alpha <= 0.001) continue;

            const isGround = p.role === "ground";
            const stepDx = p.x - p.px;
            const stepDy = p.y - p.py;
            const dist = Math.hypot(stepDx, stepDy);
            const speed = dist * invDt;

            if (
              !prefersReducedMotion &&
              !isGround &&
              speed > streakCfg.minSpeed &&
              (p.scatter < 0.44 || speed > streakCfg.minSpeed * 1.8)
            ) {
              const len = Math.min(streakCfg.maxLen, speed * streakCfg.lenMul);
              const inv = 1 / (dist || 1);
              const dx = stepDx * inv;
              const dy = stepDy * inv;
              const a = Math.min(0.45, alpha * streakCfg.alphaMul * (0.05 + speed * 0.013));
              ctx.strokeStyle = `rgba(170, 245, 255, ${a})`;
              ctx.lineWidth = 1.3;
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(p.x - dx * len, p.y - dy * len);
              ctx.stroke();

              if (speed > 2.2 && ph.name === "surge") {
                bloomCtx.strokeStyle = `rgba(150, 240, 255, ${Math.min(
                  0.16,
                  alpha * 0.085 * (speed - 0.8)
                )})`;
                bloomCtx.lineWidth = 2.8;
                bloomCtx.beginPath();
                bloomCtx.moveTo(p.x, p.y);
                bloomCtx.lineTo(p.x - dx * len, p.y - dy * len);
                bloomCtx.stroke();
              }
            }

            const tw = 0.85 + 0.15 * Math.sin(tMs * 0.007 + p.twinkle);
            const drawSize = p.size * (0.9 + 0.35 * tw) * (isGround ? 0.82 : 1);
            const sprite = isGround ? spriteDot : alpha > 0.11 ? spriteHot : spriteDot;
            const s = (sprite.width / 2) * drawSize * 0.18;

            ctx.globalAlpha = Math.min(1, alpha * (isGround ? 0.98 : 0.9));
            ctx.drawImage(sprite, p.x - s, p.y - s, s * 2, s * 2);

            if (!isGround) {
              const bloomA =
                ph.name === "surge"
                  ? alpha * 0.65
                  : ph.name === "ramp"
                  ? alpha * 0.5
                  : ph.name === "stable"
                  ? alpha * 0.46
                  : alpha * 0.34;
              if (bloomA > 0.03) {
                const hs = (spriteHot.width / 2) * drawSize * 0.27;
                bloomCtx.globalAlpha = Math.min(1, bloomA);
                bloomCtx.drawImage(spriteHot, p.x - hs, p.y - hs, hs * 2, hs * 2);
              }
            }
          }

          if (draw) {
            bloomCtx.restore();
            ctx.restore();
          }
        }

        function warmupTo(targetMs) {
          const tTarget = Math.max(0, Math.min(targetMs, PHASE.cycleMs * 3));
          requestedReset = false;
          lastPhaseName = "";
          lastT = 0;
          resetCycle(0);

          let t = 0;
          while (t < tTarget) {
            const next = Math.min(tTarget, t + FRAME_MS);
            const dt = (next - t) / FRAME_MS;
            const ph = ensurePhase(phaseAt(next), next);
            if (ph.t < lastT) {
              resetCycle(next);
              lastPhaseName = "";
            }
            advanceParticles(next, dt, ph, false);
            lastT = ph.t;
            t = next;
          }
        }

        function step(now) {
          if (startAt == null) startAt = now - START_OFFSET_MS;
          if (paused) {
            if (!STILL_FRAME) requestAnimationFrame(step);
            return;
          }

          const tMs = now - startAt;
          const ph = ensurePhase(phaseAt(tMs), tMs);
          window.__heartDebug = { tMs, phase: ph.name, k: ph.k, seed: SEED };

          if (!warmedUp) {
            warmedUp = true;
            if (START_OFFSET_MS > 0) {
              warmupTo(START_OFFSET_MS);
              lastNow = now;
            }
          }

          const dtFrames =
            lastNow == null ? (START_OFFSET_MS > 0 ? 0 : 1) : (now - lastNow) / FRAME_MS;
          lastNow = now;
          if (requestedReset) {
            resetCycle(tMs);
            requestedReset = false;
            lastT = ph.t;
          } else if (ph.t < lastT) {
            resetCycle(tMs);
          }
          lastT = ph.t;

          backgroundFade(ph, tMs);
          bloomCtx.globalCompositeOperation = "source-over";
          const bloomFade = (() => {
            switch (ph.name) {
              case "intro":
                return 0.4;
              case "cloud":
                return 0.32;
              case "reform":
                return 0.3;
              case "ramp":
                return 0.28;
              case "surge":
                return 0.24;
              case "stable":
                return 0.28;
              default:
                return 0.3;
            }
          })();
          bloomCtx.fillStyle = `rgba(0,0,0,${bloomFade})`;
          bloomCtx.fillRect(0, 0, state.w, state.h);

          drawBase(ctx, tMs, ph, "main");
          drawThreads(ctx, tMs, ph, "main");
          drawBase(bloomCtx, tMs, ph, "bloom");
          drawThreads(bloomCtx, tMs, ph, "bloom");

          advanceParticles(tMs, dtFrames, ph, true);

          ctx.save();
          ctx.globalCompositeOperation = "screen";
          if (!prefersReducedMotion) {
            ctx.globalAlpha = BLOOM.intensity * 0.65;
            ctx.filter = "blur(8px)";
            ctx.drawImage(bloomCanvas, 0, 0, state.w, state.h);
            ctx.filter = "none";
          }
          ctx.globalAlpha = BLOOM.intensity;
          ctx.drawImage(bloomCanvas, 0, 0, state.w, state.h);
          ctx.restore();

          if (!STILL_FRAME) requestAnimationFrame(step);
        }

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, 1, 1);
        requestAnimationFrame(step);
      })();
    </script>
  </body>
</html>
